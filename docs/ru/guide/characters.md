# Персонажи 

Персонажи – это акторы, используемые для показа элементов сцены, размещённых поверх [фонов](/ru/guide/backgrounds.md). 

Актор персонажа определяется именем, внешностью, видимостью, трансформацией (что включает в себя положение, поворот, масштаб) и направлением взгляда. Он может изменять внешность, видимость, трансформацию и направление взгляда с течением времени.

Поведение персонажей может быть настроено с помощью контекстного меню `Naninovel -> Configuration -> Characters`; доступные варианты см. в [руководстве по конфигурации](/ru/guide/configuration.md#персонажи). Доступ к менеджеру ресурсов персонажей можно получить с помощью контекстного меню `Naninovel -> Resources -> Characters`.

![Добавление персонажа](https://i.gyazo.com/c8a4f7f987621831b4a2ecb3145a4a07.png)

В случае, если у вас есть много персонажей и/или внешностей для каждого персонажа, и вам неудобно назначать их все через меню редактора, вы можете просто поместить их в папку `Resources/Naninovel/Characters`, сгруппированными в папки, соответствующие ID их акторов. Например, чтобы добавить внешнность для актора персонажа с ID "Kohaku", сохраните текстуры (спрайты) в папке `Resources/Naninovel/Characters/Kohaku`, и они автоматически будут доступны в сценариях.

Вы можете дополнительно организовать ресурсы внешностей с помощью подпапок, если хотите; в этом случае используйте прямой слеш (`/`) при ссылке на них в скриптах Naninovel. Например, текстура внешности, сохранённая как `Resources/Naninovel/Characters/Kohaku/Casual/Angry`, может быть объявлена в сценариях как `Casual/Angry`.

Также можно использовать [систему адресируемых ассетов](/ru/guide/resource-providers.md#адресация ), чтобы вручную распределить ресурсы. Чтобы предоставить доступ к ассету, назначьте адрес, равный пути, который вы использовали бы для его объявления с помощью метода, описанного выше, за исключением опущенной части "Resources/". Например, для объявления внешности "Happy" для персонажа "Kohaku" назначьте ассету следующий адрес: `Naninovel/Characters/Kohaku/Happy`. Имейте в виду, что адресируемый провайдер по умолчанию не используется в редакторе; вы можете разрешить его, включив свойство `Enable Addressable In Editor` в меню конфигурации провайдера ресурсов.

В сценариях Naninovel персонажи в основном контролируются с помощью команды [@char]:

```nani
; Вывод персонажа с именем `Sora` с внешностью по умолчанию.
@char Sora

; То же, что и выше, но с применением внешности `Happy`.
@char Sora.Happy

; То же, что и выше, но также размещая персонажа на расстоянии 45% от левой границы
; экрана и на 10% от нижней границы; также заставляя его смотреть влево.
@char Sora.Happy look:left pos:45,10
```

## Позы

Каждый персонаж имеет свойство `Poses`, позволяющее задавать различные именованные состояния ("позы").

![](https://i.gyazo.com/5b022d32eddb3e721ed036c96f662f5d.png)

Название позы может быть использовано в качестве внешности в команде [@char] для применения всех параметров, указанных в позе сразу, вместо того, чтобы указывать их по отдельности с помощью команд параметров.

```nani
; Данная поза `SuperAngry` определена для персонажа `Kohaku`,
; применяет все параметры, указанные в состоянии позы.
@char Kohaku.SuperAngry

; То же, что и выше, но с использованием перехода `DropFade` длительностью в 3 секунды.
@char Kohaku.SuperAngry transition:DropFade time:3
```

Обратите внимание, что когда поза используется в качестве внешности, вы все еще можете переопределить отдельные параметры, например:

```nani
; Данная поза `SuperAngry` определена для персонажа `Kohaku`,
; применяет все параметры, указанные в состоянии позы,
; за исключением оттенка, который переопределён отдельной командой.
@char Kohaku.SuperAngry tint:#ff45cb
```

## Отображаемые имена

В конфигурации персонажей вы можете установить `Display Name` для определенных персонажей. При установке отображаемое имя будет выводиться в метке имени в принтере вместо ID персонажа. Это позволяет использовать составные имена персонажей, содержащие пробелы и специальные символы (что не допускается для ID).

Для локализации используйте [управляемый текстовый](/ru/guide/managed-text) документ "CharacterNames", который автоматически создается при запуске задачи генерировать управляемые текстовые ресурсы. Значения из документа "CharacterNames" не будут переопределять значения, заданные в метаданных персонажей, пока они находятся в исходной локали.

Можно привязать отображаемое имя к пользовательской переменной, чтобы динамически изменять его на протяжении всей игры с помощью сценариев Naninovel. Чтобы связать отображаемое имя, укажите имя пользовательской переменной, заключенной в фигурные скобки, в меню конфигурации персонажей.

![](https://i.gyazo.com/9743061df462bd809afc45bff20bbb6d.png)

После этого вы можете изменять значение переменной в сценариях, и это будет также изменять отображаемое имя:

```nani
@set PlayerName="Mistery Man"
Player: ...

@set PlayerName="Dr. Stein"
Player: You can call me Dr. Stein.
```

Также можно использовать функцию привязки имени, чтобы позволить игроку выбрать свое отображаемое имя с помощью команды [@input]:

```nani
@input PlayerName summary:"Choose your name."
@stop
Player: You can call me {PlayerName}.
```

## Цвета сообщений

Если в конфигурации персонажей включена функция `Use Character Color`, текстовые сообщения принтера и метки имен будут окрашены в указанные цвета, если соответствующий ID персонажа указан в команде [@print] или общей текстовой строке.

В этом видео показано, как использовать отображаемые имена и цвета персонажей.

[!!u5B5s-X2Bw0]

## Текстуры аватаров

Вы можете назначать текстуры аватаров персонажам, используя параметр `avatar` команды [@char]. Аватары будут отображаться совместимыми текстовыми принтерами, когда они выводят текстовое сообщение, связанное с этим персонажем. В настоящее время функцию аватаров поддерживают только текстовые принтеры `Wide` и `Chat`.

![](https://i.gyazo.com/83c091c08846fa1cab8764a8d4dddeda.png)

Чтобы использовать любой заданный аватар, вы должны сначала добавить его в ресурсы аватара и дать ему имя. Вы можете сделать это с помощью свойства `Avatar Resources` в меню конфигурации персонажей.

![](https://i.gyazo.com/5a0f10d174aa75ed87da1b472567e40b.png)

::: note
Имена аватаров могут быть произвольными и не обязаны содержать существующий ID персонажа или внешность. Это требуется только в том случае, если вы хотите связать аватар с персонажем, чтобы он отображался автоматически.
:::

Теперь вы можете показать определенную текстуру аватара следующим образом:

```nani
@char CharacterId avatar:AvatarName
```

Чтобы установить аватар по умолчанию для персонажа, дайте имя ресурсу текстуры аватара, который равен `CharacterID/Default`; например, чтобы установить аватар по умолчанию для персонажа с ID `Kohaku`, дайте имя ресурсу аватара `Kohaku/Default`. Заданные аватары по умолчанию будут отображаться автоматически, даже если параметр `avatar` не указан в командах [@char].

Кроме того, можно связать аватары с определенными внешностями персонажа, так что когда персонаж будет менять внешность, аватар также автоматически будет меняться. Для этого назовите ресурсы аватара в следующем формате: `CharacterID/CharacterAppearance`, где `CharacterAppearance` – это имя внешности, которой сопоставляется ресурс аватара.

Обратите внимание, что **аватары не связаны напрямую с внешностью персонажа** и не должны рассматриваться как способ показать персонажа в сцене. Внешность, указанная в диспетчере ресурсов персонажа, является фактическим представлением персонажа в сцене. Аватары – это автономная функция, которая "вводит" произвольное изображение в совместимый текстовый принтер.

Можно показать только аватар персонажа внутри текстового принтера, но скрыть самого персонажа, установив параметр `visible` команды [@char] в значение `false`, например:
```nani
@char CharacaterId visible:false
```

Если вы постоянно меняете аватары, в то время как сам персонаж должен оставаться скрытым, вы можете отключить `Auto Show On Modify` в меню конфигурации персонажей; когда он отключен, вам не нужно будет указывать `visible:false`, чтобы изменить какие-либо параметры персонажа, пока он скрыт.

## Подсветка говорящего

Если этот параметр включен в конфигурации персонажей, он будет окрашивать персонажа в зависимости от того, связано ли с тем последнее напечатанное сообщение.

[!!gobowgagdyE]

## Синхронизация движений губ со звуком

[Универсальные](/ru/guide/characters.md#универсальные-персонажи) и [Live2D](/ru/guide/characters.md#персонажи-Live2D)-реализации персонажей поддерживают так называемую функцию "синхронизации движений губ со звуком", позволяя управлять анимацией рта персонажа, пока от его имени печатается сообщение, для чего отправляя соответствующие события.

[!!fx_YS2ZQGHI]

Когда включена функция [автоозвучивания](/ru/guide/voicing.md#автоматическое озвучивание), события синхронизации губ будут управляться озвучкой; в противном случае печатные текстовые сообщения активируют события. В последнем случае вам, вероятно, иногда захочется вручную запустить или остановить синхронизацию губ (например, чтобы предотвратить движение рта при печати знаков препинания); в таких случаях используйте команду [@lipSync].

См. документацию по реализации [универсальных](/ru/guide/characters.md#универсальные-персонажи) и [Live2D-](/ru/guide/characters.md#персонажи-Live2D)персонажей ниже для получения подробной информации о том, как настроить функцию синхронизации губ.

## Привязанный принтер

Существует возможность привязать [текстоый принтер](/ru/guide/text-printers.md) с персонажем, используя параметр `Linked Printer`.

![](https://i.gyazo.com/50ca6b39cd7f708158678339244b1dc4.png)

При подключении принтер будет автоматически использоваться для обработки сообщений, выводимых от имени этого персонажа.

Имейте в виду, что команды [@print] (которые также используются при печати общих текстовых строк) по умолчанию используют привязанные принтеры по умолчанию и скрывают другие видимые принтеры. Когда принтеры привязаны к персонажам, команды печати автоматически изменят текущий видимый и стандартный текстовый принтер, одновременно печатая текст, связанный с соответствующим персонажем. Такое поведение можно предотвратить, отключив свойство `Auto Default` в меню конфигурации принтера актора; если оно отключено, вам придется вручную показывать/скрывать и переключать принтеры по умолчанию с помощью команд [@printer].

## Спрайтовые персонажи 

Спрайтовая реализация акторов персонажей является наиболее распространенной и простой; она использует набор ассетов [спрайтов](https://docs.unity3d.com/Manual/Sprites) для представления внешности персонажа. Источником спрайтов могут быть изображения (текстуры) любых форматов, [поддерживаемых Unity](https://docs.unity3d.com/Manual/ImportingTextures).

## Нарезанные спрайты персонажей

Основанная на пакете [Sprite Dicing](https://github.com/Elringus/SpriteDicing) с открытым исходным кодом реализация `DicedSpriteCharacter` позволяет значительно уменьшить размер сборки и занимаемую текстурами память за счет повторного использования текстурных областей спрайтов персонажей.

![Нарезка спрайта](https://i.gyazo.com/af08d141e7a08b6a8e2ef60c07332bbf.png)

Установите пакет через [менеджер пакетов Unity](https://docs.unity3d.com/Manual/upm-ui.html): откройте окно менеджера пакетов (Window -> Package Manager), нажмите кнопку "+", выберите "Add package from git URL", введите `https://github.com/Elringus/SpriteDicing.git#package` в поле ввода и нажмите кнопку "Add".

[!b54e9daa9a483d9bf7f74f0e94b2d38a]

Ассеты `DicedSpriteAtlas`, содержащие внешности персонажей, используются в качестве ресурсов для нарезанных спрайтов персонажей. Каждая внешность сопоставляется по имени с нарезкой спрайтов, содержащихся в атласе.

Имейте в виду, что некоторые свойства метаданных нарезанных спрайтов (например, пиксели на единицу, pivot) управляются ассетом атласа, в то время как значения в конфигурации персонажей применяются к создаваемой текстуре, используемой для представления фактического спрайта. При изменении свойств атласа не забудьте перестроить его, чтобы изменения вступили в силу.

![](https://i.gyazo.com/3765726bd326bb7a8a03a653f458cd3d.png)

Следующий видеогайд охватывает создание и настройку атласа нарезанного спрайта, добавление нового нарезанного персонажа на основе созданного атласа и управление персонажем из сценария Naninovel.

[!!6PdOAOsnhio]

## Послойные персонажи

Послойная реализация позволяет создавать персонажей из нескольких спрайтов (слоев), а затем переключать их по отдельности или группами с помощью сценариев Naninovel во время выполнения.

Чтобы создать префаб послойного персонажа, используйте контекстное меню `Create -> Naninovel -> Character -> Layered`. Войдите в [режим редактирования префаба](https://docs.unity3d.com/Manual/EditingInPrefabMode.html) для составления слоев. По умолчанию будет создано несколько слоев и групп. Вы можете использовать их или удалить и добавить свои собственные.

Каждый дочерний игровой объект корневого объекта префаба с компонентом [спрайтового рендерера](https://docs.unity3d.com/Manual/class-SpriteRenderer.html) считается *слоем*; другие объекты считаются *группами*. Помимо организации и трансформации, размещение слоев внутри групп позволит вам выбрать один слой или отключить/включить все слои внутри группы с помощью одного выражения в сценарии Naninovel (подробнее об этом позже).

Чтобы скрыть некоторые слои от просмотра по умолчанию, отключите компоненты рендерера спрайтов (а не игровые объекты).

Белая рамка поверх префаба используется для описания холста актера, который будет визуализирован в готовую текстуру во время выполнения. Убедитесь, что вы минимизировали пустые области внутри кадра, перемещая слои и группы, чтобы предотвратить потерю памяти на текстуры и обеспечить правильную работу якорей.

![](https://i.gyazo.com/4ff103c27858ac9671ba3b94ab1ade20.png)

Вы можете масштабировать корневой игровой объект, чтобы точно настроить размер актора по умолчанию.

При создании послойных изображений персонажей в Photoshop вы можете использовать [пакет Unity для импорта PSD](https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@3.0/manual/index.html), чтобы автоматически генерировать префаб персонажа с сохранением всех слоев и их положений. Чтобы сохранить иерархию слоев, обязательно включите опцию `Use Layer Grouping` в настройках импорта.

Не забудьте добавить созданный послойный префаб к ресурсам персонажей (`Naninovel -> Resources -> Characters`). Выберите "Naninovel.LayeredCharacter" и перетащите префаб в поле "Resource" при настройке записи ресурса.

Для управления послойными персонажами в сценариях Naninovel используйте команду [@char] так же, как и в других реализациях персонажей. Единственное отличие заключается в том, как вы объявляете внешность: вместо одного ID используйте *выражение композиции слоёв*. Существует три типа выражений:

 - Включить один слой в группе: `group>layer`
 - Включить слой: `group+layer`
 - Отключить слой: `group-layer`

Например, рассмотрим персонажа "Miho", который имеет группу "Body" с тремя слоями: "Uniform", "SportSuit" и "Pajama". Чтобы включить слой "Uniform" и отключить все остальные, используйте следующую команду:

```nani
@char Miho.Body>Uniform
```

Чтобы включить или отключить слой, не затрагивая другие слои в группе, используйте "+" и "-" соответственно вместо ">". Вы также можете указать несколько композиционных выражений, разделив их запятыми:

```nani
; Добавить очки, убрать шляпу, выбрать эмоцию "Cool".
@char CharId.Head/Accessories+BlackGlasses,Head-Hat,Head/Emotions>Cool
```

Чтобы выбрать слой вне каких-либо групп (дочерний объект корневого объекта префаба), просто пропустите группу, например:

```nani
; Дан слой "Halo" – дочерний объект корневого объекта префаба, убрать его
@char CharId.-Halo
```

Кроме того, можно воздействовать на все слои внутри группы (а также на ее соседей при использовании выборного выражения), опуская имя слоя в выражении композиции:

```nani
; Убрать все слои из группы "Body/Decoration".
@char CharId.Body/Decoration-

; Добавить все существующие слои.
@char CharId.+

; Даны группы `Poses/Light` и `Poses/Dark` (each containing multiple layers), 
; добавить все спрайты из группы `Light` и убрать все из группы `Dark`.
@char CharId.Poses/Light>
```

Приведенные выше выражения будут рекурсивно воздействовать не только на прямых потомков выбранных групп, но и на все слои, содержащиеся в нижележащих группах.

Если внешность не задана (например, `@char CharId` без предварительной настройки внешности), будет использоваться внешность умолчанию; внешность послойных персонажей по умолчанию равна тому, как выглядит послойный префаб в редакторе.

Видео ниже демонстрирует, как настраивать послойного персонажа и управлять им с помощью команд Naninovel.

[!!Bl3kXrg8tiI]

::: note
Команда `@char Miho.Shoes>`, показанная в видео, выбирает группу "Shoes" (отключая все соседние группы), но не скрывает её. Правильная команда для скрытия группы – `@char Miho.Shoes-`.
:::

Можно сопоставить композиционные выражения для ключей с помощью свойства `Composition Map` компонента `Layered Actor Behaviour`:

![](https://i.gyazo.com/ede5cde3548a3187aa714d3e140750ba.png)

– после этого ключи могут быть использованы для определения внешности послойного персонажа:

```nani
; Соответствует `Body>Uniform,Hair/Back>Straight,Hair/Front>Straight,Shoes>Grey`.
@char Miho.Uniform
; Соответствует `Hair/Back>Straight,Hair/Front>Straight`.
@char Miho.StraightHair
```

При редактировании префаба послойного персонажа можно предварительно просмотреть заданные композиционные выражения, щелкнув правой кнопкой мыши по записи выражения и выбрав пункт "Preview Composition".

![](https://i.gyazo.com/9fb0aeccf4f33245d9f975592ee86dbc.gif)

Имейте в виду, что объекты слоёв не визуализируются непосредственно камерами Unity во время выполнения; вместо этого они визуализируются один раз при каждом изменении композиции (внешности) во временную собранную текстуру, которая затем подается в сетку, видимую для камеры Naninovel. Эта настройка необходима для предотвращения проблем с прорисовкой полупрозрачных элементов и поддержки эффектов анимации перехода.

## Универсальные персонажи 

Универсальный персонаж – это наиболее гибкая реализация актора персонажа. Он основан на сборке с компонентом `CharacterActorBehaviour`, прикрепленным к корневому объекту. Изменения внешности и все остальные параметры персонажей маршрутизируются как [события Unity](https://docs.unity3d.com/Manual/UnityEvents.html), позволяя реализовать поведение базового объекта любым удобным вам способом.

![](https://i.gyazo.com/9f799f4152782afb6ab86d3c494f4cc4.png)

Чтобы создать префаб универсального персонажа по шаблону, используйте контекстное меню `Create -> Naninovel -> Character -> Generic`.

Для настройки функции синхронизации губ для универсальных персонажей, используйте события Unity `On Started Speaking` и `On Finished Speaking` компонента `CharacterActorBehaviour`. Когда персонаж становится или перестает быть автором любого печатного сообщения (или, скорее, когда сообщение полностью раскрывается), эти события будут вызваны, позволяя вам вызвать любую логику, такую как запуск или остановка анимации рта контролируемого персонажа. Это подобно тому, как работают события пользовательского интерфейса `On Show` и `On Hide`; найти, как они могут быть использованы для управления анимацией, можно в [руководстве по настройке UI](/ru/guide/user-interface.md#добавление-пользовательских-UI).

Ознакомьтесь со следующим видеоуроком как с примером по настройке 3D-модели в качестве универсального персонажа и внесению изменений внешности в анимацию модели с помощью компонента [Animator](https://docs.unity3d.com/Manual/class-AnimatorController.html) компонент.


[!!HPxhR0I1u2Q]


## Персонажи Live2D

Реализация персонажей Live2D использует ассеты, созданные с помощью софта для 2D-моделирования и анимации [Live2D Cubism](https://www.live2d.com).

Чтобы иметь возможность использовать эту реализацию, необходимо сначала установить [Live2D Cubism SDK для Unity](https://live2d.github.io/#unity). Обратитесь к официальной документации Live2D для получения инструкций по установке и использованию.

После этого скачайте и импортируйте [пакет расширения Live2D](https://github.com/Elringus/NaninovelLive2D/raw/master/NaninovelLive2D.unitypackage).

Префаб модели Live2D, используемый в качестве ресурса для реализации, должен иметь компонент `Live2DController`, прикрепленный к корневому объекту. Изменения внешности направляются в компонент аниматора как команды [SetTrigger](https://docs.unity3d.com/ScriptReference/Animator.SetTrigger.html), используя внешность как имя триггера. Например, если у вас есть Live2D-префаб персонажа "Kaori", и вы хотите вызвать триггер с именем "Surprise", используйте следующую команду:

```nani
@char Kaori.Surprise
```

Обратите внимание, что приведенная выше команда будет только пытаться вызвать [SetTrigger](https://docs.unity3d.com/ScriptReference/Animator.SetTrigger.html) с аргументом "Surprise" на контроллере аниматора, прикрепленного к префабу; вы должны самостоятельно составить нижележащую систему [аниматора](https://docs.unity3d.com/Manual/Animator).

::: warn
Последняя версия Cubism SDK для Unity работает непосредственно с компонентом `Animator`; выражения и позы (экспортированные как expression.json и pose.json), которые ранее использовались в Cubism 2.x, теперь [устарели](https://docs.live2d.com/cubism-sdk-tutorials/blendexpression) и не поддерживаются расширением Naninovel для Live2D.
:::

Когда компоненты Live2D `CubismLookController` и `CubismMouthController` присутствуют и настроены на префаб модели Live2D, `Live2DController` может дополнительно использовать их для управления направлением взгляда и анимацией рта (функцией синхронизации губ) персонажа.

![](https://i.gyazo.com/498fe948bc5cbdb4dfc5ebc5437ae6b4.png)

Обратитесь к документации Live2D по [трекингу глаз](https://docs.live2d.com/cubism-sdk-tutorials/lookat) и [синхронизации губ](https://docs.live2d.com/cubism-sdk-tutorials/lipsync) для получения подробной информации о настройке.

Имейте в виду, что `Live2DController` ожидает игровой объект "Drawables" внутри префаба модели Live2D (создается автоматически при импорте моделей Live2D в Unity); контроллер будет масштабировать этот объект во время выполнения в соответствии с параметром "scale" команд [@char]. Следовательно, любые локальные значения, заданные в редакторе, будут проигнорированы. Чтобы установить начальный масштаб для префабов Live2D, пожалуйста, используйте масштаб корневого игрового объекта, как [показано в видеогайде](https://youtu.be/rw_Z69z0pAg?t=353).

При установке расширения Live2D в меню конфигурации Naninovel появится пункт "Live2D", содержащий следующие параметры:

![](https://i.gyazo.com/435a4824f0ce0dd8c9c3f29d457bab24.png)

Слой рендеринга задает слой, применяемый для префабов Live2D, и маску обрезки, используемую для камер, которые будут рендерить префабы. Поле рендеровой камеры позволяет использовать пользовательскую настройку для камеры рендеринга (камера рендеринга по умолчанию хранится в папке пакетов "Prefabs"). Смещение камеры позволяет смещать камеру рендеринга от рендерируемого префаба; вы можете использовать эти параметры для равномерного позиционирования всех префабов Live2D относительно камеры.

Следующий видеогайд охватывает экспорт персонажа Live2D из Cubism Editor, настройку префаба, создание простого аниматора и управление персонажем из сценария Naninovel.

[!!rw_Z69z0pAg]

::: example
Ознакомьтесь с [примером проекта на GitHub](https://github.com/Elringus/NaninovelLive2D), где персонаж Live2D используется в Naninovel. Имейте в виду, что ни пакеты Naninovel, ни пакеты Live2D SDK не поставляются вместе с проектом, поэтому после его первого открытия появятся ошибки компиляции; импортируйте Naninovel из Asset Store и Live2D Cubism SDK с их веб-сайта, чтобы решить эти проблемы.
:::