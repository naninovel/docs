# キャラクター

[背景](/ja/guide/backgrounds) とは対照的に、キャラクターはシーンの最前面に配置されるシーンエンティティを表すために使用されるアクターです。

キャラクターアクターは、名前、外観、可視性、変換（位置、回転、スケール）、および向きで定義されます。

キャラクターの動作は、`Naninovel -> Configuration -> Characters` コンテキストメニューを使用するか、[アクターレコード](/ja/guide/characters#アクターレコード) を使用して構成できます。利用可能なオプションについては、[構成ガイド](/ja/guide/configuration#キャラクター) を参照してください。キャラクターのリソースマネージャーには、`Naninovel -> Resources -> Characters` コンテキストメニューを使用してアクセスできます。

シナリオスクリプトでは、キャラクターは [@char] コマンドで制御されます。

```nani
; "Sora" という名前のキャラクターをデフォルトの外観で表示します。
@char Sora

; 上記と同じですが、外観を "Happy" に設定します。
@char Sora.Happy

; 上記と同じですが、キャラクターをシーンの左端から45%、
; 下端から10%離れた位置に配置し、
; 左を向くようにします。
@char Sora.Happy look:left pos:45,10
```

::: tip
シーン上でのアクターの配置を支援するために、[Scene Assistant](https://github.com/idaocracy/NaninovelSceneAssistant) 拡張機能の使用を検討してください。
:::

## アクターレコード

キャラクターが多く、エディタメニューですべてを割り当てるのが不便な場合は、アクターレコードアセット（`Create -> Naninovel -> Actor Record -> Character`）を使用してください。これらはマルチ編集をサポートしており、フォルダでレコードを整理できます。例については、以下のビデオを確認してください。

![](https://www.youtube.com/watch?v=2YP-36THHvk)

外観リソースをアクターレコードに関連付けるには、[Addressable Asset System](/ja/guide/resource-providers#addressable) を使用できます。たとえば、"Happy" の外観を "Kohaku" キャラクターに関連付けるには、テクスチャアセットを `Naninovel/Characters/Kohaku/Happy` アドレスに割り当て、`Naninovel` ラベルを追加します。Addressableプロバイダーの使用の詳細については、[リソースプロバイダードキュメント](/ja/guide/resource-providers#addressable) を参照してください。

## ポーズ

各キャラクターには、名前付きの状態（ポーズ）を指定できる `Poses` プロパティがあります。

![](https://i.gyazo.com/a049313d5c7cfa9897dd8c5f5ee00af3.png)

ポーズ名は、[@char] コマンドで外観として使用して、コマンドパラメータを介して個別に指定する代わりに、ポーズで指定されたすべての選択されたパラメータを一度に適用できます。

```nani
; "Kohaku" に "SuperAngry" ポーズが定義されている場合、
; ポーズで指定されたすべての選択されたパラメータを適用します。
@char Kohaku.SuperAngry

; 上記と同じですが、3秒かけて "DropFade" トランジションを使用します。
@char Kohaku.SuperAngry via:DropFade time:3
```

ポーズを外観として使用する場合でも、個々のパラメータをオーバーライドできることに注意してください。例：

```nani
; "Kohaku" に "SuperAngry" ポーズが定義されている場合、
; ポーズ状態で指定されたすべてのパラメータを適用しますが、
; コマンドでオーバーライドされているtintは除きます。
@char Kohaku.SuperAngry tint:#ff45cb
```

キャラクターと背景の構成には、`Shared Poses` もあります。これらのポーズは、それぞれのアクター間ですべて共有されます。共有ポーズの使用例としては、発話中/非発話中のテンプレートの再利用や、カメラに対する事前定義されたステージの作成などがあります。

![](https://i.gyazo.com/c4c6d850d2a6efae269164af58da1ed3.png)

アクターごとのポーズと共有ポーズの両方を、専用の `pose` パラメータを介して適用することもできます。

```nani
@char Kohaku.Happy pose:DownLeft
@char Yuko.Surprise pose:UpCenter
@char Misaki pose:UpRight
```

![](https://i.gyazo.com/7bdbad68dd08c97032af174875ac4978.png)

アクターごとのポーズは共有ポーズよりも優先されます。つまり、アクターのポーズ名が共有ポーズと同じ場合、アクターのポーズが使用されます。これにより、必要に応じて特定のアクターの共有ポーズをオーバーライドできます。

## 表示名

キャラクター構成で `Has Name` が有効になっている場合、特定のキャラクターに `Display Name` を設定できます。設定すると、キャラクターのIDの代わりに、プリンターの名前ラベルUIに表示名が表示されます。これにより、スペースや特殊文字（IDには許可されていません）を含む複合キャラクター名を使用できます。

あるいは、名前は "CharacterNames" [管理テキスト](/ja/guide/managed-text) ドキュメントで指定できます。これは、管理テキストリソースの生成タスクを実行すると自動的に作成されます。これを使用して、表示名をローカライズしたり、Unityエディタの外部で編集したりします。管理テキストドキュメントのレコードは、アクター構成で設定された表示名よりも優先され、それらをオーバーライドします。

シナリオスクリプトを介してゲーム全体で動的に変更するために、表示名をカスタム変数にバインドすることが可能です。表示名をバインドするには、キャラクター構成メニューで中括弧で囲まれたカスタム変数の名前を指定します。

![](https://i.gyazo.com/931d0f6b09c77e13e7800d102c089d44.png)

その後、スクリプトで変数の値を変更すると、表示名も変更されます。

```nani
@set PlayerName="Mystery Man"
Player: ...

@set PlayerName="Dr. Stein"
Player: Dr. Steinと呼んでください。
```

名前バインディング機能を使用して、[@input] コマンドを使用してプレイヤーが表示名を選択できるようにすることも可能です。

```nani
@input PlayerName summary:"あなたの名前を選んでください。"
Player: {PlayerName}と呼んでください。
```

中括弧の内容は実際には完全な [スクリプト式](/ja/guide/script-expressions) として扱われ、表示名を評価するための複雑なシナリオを可能にします。たとえば、ある時点までキャラクターの事前定義されたローカライズ可能な表示名を保持し、その後プレイヤーにカスタム名を選択させたい場合があります。

問題のキャラクターが "Char1" IDを持ち、事前定義された名前が `T_PredefinedName` [管理テキストレコード](/ja/guide/managed-text#スクリプトテキスト) として保存され、プレイヤーが入力した値が `name` [カスタム変数](/ja/guide/custom-variables) として保存され、プレイヤーが名前を設定したときに `nameSet` 変数が `true` に設定されるとします。次の式を `Display Name` プロパティに割り当てます：`{ nameSet ? name : T_PredefinedName }`。

![](https://i.gyazo.com/b4bed71310ae8d0f80aff11d910d6e5b.png)

次に、次のシナリオスクリプトを使用します。

```nani
@char Char1

Char1: 私の名前は現在 `T_PredefinedName` 管理テキストレコードによって事前定義されています。
Char1: ローカライズ可能です。ロケールを変更してみてください。それに応じて更新されます。
Char1: さて、プレイヤーにカスタム名を入力させます。

; `value` パラメータを介して割り当てられたデフォルトの入力値に注意してください。
; 管理テキストから取得され、ローカライズも可能です。
@input name summary:"あなたの名前を選んでください。" value:{T_DefaultName}

; ここで、値をどこから取得するかを決定するために
; 表示名の式で使用される変数を設定します。
@set nameSet=true

Char1: 私の表示名は `name` カスタム変数にバインドされました。
```

`Has Name` が無効になっている場合、表示名もキャラクターIDもプリンターUIに表示されません。これは、[リンクされたプリンター](/ja/guide/characters#リンクされたプリンター) を持つ可能性があるがIDを表示すべきではない [ナレーターキャラクター](/ja/guide/characters#ナレーターキャラクター) に役立ちます。

## 名前ラベル

上記の表示名はほとんどの場合に推奨されますが、数行だけアクターの名前を変更したり、同じ行の著者を複数のアクターにしたりしたい場合があります。そのような発生ごとに専用のアクターまたは変数の表示名を設定するのは非実用的です。代わりに、`as` [汎用パラメータ](/ja/guide/scenario-scripting#汎用パラメータ) の使用を検討してください。

```nani
; "Kohaku" キャラクターには構成で設定されたカスタム表示名があるかもしれませんが、
; この行は名前として "Someone" を使用して表示します。
Kohaku: Lorem ipsum.[< as:"Someone"]

; 著者名として "All Together" を表示して行を表示し、
; すべての表示されているキャラクターを表示されたテキストの著者にします。
*: Lorem ipsum![< as:"All Together"]

; 同様ですが、"Kohaku" と "Yuko" のみを著者にします。
Kohaku,Yuko: Lorem ipsum?[< as:"Kohaku and Yuko"]
```

— `as` パラメータはローカライズ可能であり、翻訳のためにスクリプトローカライズドキュメントに公開されます。さらに、[話者ハイライト](/ja/guide/characters#話者ハイライト) 機能は、著者IDで指定された `*` と `,` を認識し、すべての/選択されたキャラクターを話者としてハイライトします。

## メッセージの色

キャラクター構成で `Use Character Color` が有効になっている場合、[@print] コマンドまたは汎用テキストラインで対応するキャラクターIDが指定されると、プリンターのテキストメッセージと名前ラベルが指定された色で着色されます。

次のビデオは、表示名とキャラクターカラーの使用方法を示しています。

![](https://www.youtube.com/watch?v=u5B5s-X2Bw0)

## アバターテクスチャ

[@char] コマンドの `avatar` パラメータを使用して、キャラクターにアバターテクスチャを割り当てることができます。アバターは、キャラクターに関連付けられたテキストメッセージを表示するときに、互換性のあるテキストプリンターによって表示されます。

![](https://i.gyazo.com/83c091c08846fa1cab8764a8d4dddeda.png)

現在、`Wide` および `Chat` 組み込みプリンター（およびそれらのTMPro対応物）のみがアバター機能をサポートしています。カスタムプリンターで機能をサポートするには、`Revealable Text Printer Panel` コンポーネントの `Author Avatar Image` プロパティに `Author Image` コンポーネントを持つゲームオブジェクトを割り当てます。

特定のアバターを使用するには、まずそれをアバターリソースに追加して名前を付ける必要があります。これは、キャラクター構成メニューの `Avatar Resources` プロパティを使用して実行できます。

![](https://i.gyazo.com/5a0f10d174aa75ed87da1b472567e40b.png)

::: info NOTE
アバター名は任意であり、既存のキャラクターIDや外観を含める必要はありません。これは、アバターをキャラクターに関連付けて自動的に表示されるようにしたい場合にのみ必要です。
:::

その後、次のように特定のアバターテクスチャを表示できます。

```nani
@char CharacterId avatar:AvatarName
```

キャラクターのデフォルトアバターを設定するには、アバターテクスチャリソース名を `CharacterID/Default` と同じにします。たとえば、ID `Kohaku` のキャラクターのデフォルトアバターを設定するには、アバターリソースに `Kohaku/Default` という名前を付けます。デフォルトのアバターは、[@char] コマンドで `avatar` パラメータが指定されていない場合でも自動的に表示されます。

アバターを特定のキャラクターの外観に関連付けて、キャラクターが外観を変更したときにアバターも自動的に変更されるようにすることも可能です。これを行うには、`CharacterID/CharacterAppearance` の形式を使用してアバターリソースに名前を付けます。ここで `CharacterAppearance` は、アバターリソースをマップする外観の名前です。

テキストプリンター内にキャラクターのアバターのみを表示し、キャラクター自体を隠すには、[@char] コマンドの `visible` パラメータを `false` に設定します。例：

```nani
@char CharacterId !visible
```

キャラクター自体を隠したままアバターを頻繁に変更する場合、キャラクター設定メニューで `Auto Show On Modify` を無効にすることを検討してください。無効にすると、隠れているキャラクターのパラメータを変更する際に `!visible` を指定する必要がなくなります。

::: info NOTE
**アバターはキャラクターの外観と直接接続されておらず**、シーン上のキャラクターを表す方法と見なすべきではありません。アバターは、互換性のあるテキストプリンターに任意の画像を「注入」するスタンドアロン機能です。実際のキャラクターをテキストプリンター（またはカスタムUI）内に表示したい場合は、[アクターをテクスチャにレンダリング](/ja/guide/characters#テクスチャへのレンダリング) する機能を確認してください。
:::

## 話者ハイライト

キャラクター構成で有効にすると、話者ハイライトは、最後に表示されたメッセージがキャラクターに関連付けられているかどうかに基づいて、指定された [ポーズ](/ja/guide/characters#ポーズ) をキャラクターに設定します。これにより、通常は色合いやスケーリングによって、「話している」キャラクターを自動的に強調表示できます。

![](https://i.gyazo.com/3817adb43d6e14f9854e5d558792c2f6.png)

複数のキャラクターに同じハイライトポーズを適用する場合は、キャラクター構成のルートにある共有ポーズを使用することをお勧めします。

## リップシンク

### イベント駆動

アニメーション可能なキャラクター実装（汎用、レイヤー、Live2Dなど）は、`On Started Speaking` および `On Finished Speaking` Unityイベントを提供します。そのようなキャラクターが表示されたメッセージの著者になったり、著者でなくなったりした場合（またはメッセージが完全に表示された場合）、イベントが呼び出され、制御されたキャラクターの口のアニメーションを開始または停止するなど、任意のカスタムロジックをトリガーできます。

![](https://www.youtube.com/watch?v=fx_YS2ZQGHI)

[オートボイス](/ja/guide/voicing#オートボイス) 機能が有効になっている場合、イベントはナレーションによって駆動されます。それ以外の場合、表示されたテキストメッセージがイベントをアクティブにします。後者の場合、手動でイベントをミュートしたい場合があるでしょう（たとえば、句読点が表示されたときに口のアニメーションを防ぐため）。そのような場合は、[@lipSync] コマンドを使用してください。

### オーディオ駆動

キャラクターの口のアニメーションをボイスオーディオクリップの実際の波形で駆動したい場合は、キャラクター構成の `Voice Source` オプションを使用してください。Unityの `Audio Source` コンポーネントを持つプレハブが割り当てられると、Naninovelはキャラクターオブジェクトの下にプレハブをインスタンス化し、オーディオソースコンポーネントを介してキャラクターの声を再生します。

キャラクターの声に使用される専用のオーディオソースコンポーネントにアクセスできるため、再生されたオーディオの波形を分析し、それに応じて口のアニメーションを駆動するカスタムソリューションをフックできます。これを実現するのに役立つサードパーティのソリューションがいくつかあります。たとえば、Live2Dの `Cubism Audio Mouth Input` コンポーネントや [SALSA](https://assetstore.unity.com/packages/tools/animation/salsa-lipsync-suite-148442) です。

## リンクされたプリンター

`Linked Printer` プロパティを使用して、[テキストプリンター](/ja/guide/text-printers) をキャラクターに関連付けることが可能です。

![](https://i.gyazo.com/50ca6b39cd7f708158678339244b1dc4.png)

リンクされると、プリンターはキャラクターによって作成されたメッセージを処理するために自動的に使用されます。

[@print] コマンド（汎用テキストラインを表示するときにも内部的に使用される）は、関連付けられたプリンターをデフォルトにし、他の表示されているプリンターをデフォルトで隠すことに注意してください。プリンターがキャラクターにリンクされている場合、printコマンドは、対応するキャラクターに関連付けられたテキストを表示しながら、現在表示されているデフォルトのテキストプリンターを自動的に変更します。プリンターアクター構成メニューの `Auto Default` プロパティを無効にすることで、この動作を防ぐことができます。無効にすると、[@printer] コマンドを使用して手動で表示/非表示を切り替え、デフォルトのプリンターを切り替える必要があります。

::: tip
プリンターを [ナレーターキャラクター](/ja/guide/characters#ナレーターキャラクター) にリンクし、`Has Name` を無効にして、ナレーションテキストをプリンターにリンクします。これにより、[@printer] を使用して非キャラクター（デフォルト）プリンターに常に戻す必要がなくなります。
:::

## デフォルトの著者

通常のキャラクターに [リンクされたプリンター](/ja/guide/characters#リンクされたプリンター) を使用する場合、明示的な著者のいない [汎用テキストライン](/ja/guide/scenario-scripting#汎用テキストライン) と [@print] コマンドを専用のプリンターにフォールバックさせたい場合があります。これにより、そのようなすべての行にナレーターIDを指定したり、[@printer] コマンドで手動でプリンターを切り替えたりする必要がなくなります。

この動作を有効にするには、`DefaultAuthor` IDを持つキャラクターレコードを作成し、その実装を `NarratorCharacter` に設定し、`HasName` オプションを無効にします。このキャラクターは、著者のいないテキストのフォールバック著者として機能し、リンクされたプリンターを自動的に適用します。

## プレースホルダーキャラクター

プレースホルダー実装はデフォルトのものであり、キャラクターを表す視覚的なアセットがまだない場合のシナリオドラフト作成を目的としています。識別子、表示名、色などのアクターメタデータを使用して、キャラクタープレースホルダーをプロシージャル生成します。

![](https://i.gyazo.com/a94fdcc2cd645738d71baa42c424ed65.png)

以下は、上にいくつかのプレースホルダーキャラクターが配置された [プレースホルダー背景](/ja/guide/backgrounds#プレースホルダー背景) の例です。現在話しているキャラクターがスケールと不透明度の増加によって強調表示されていることに注目してください。

![](https://i.gyazo.com/cebb0506d3743e2e1b20b1d3c214239a.png)

## スプライトキャラクター

キャラクターアクターのスプライト実装は最も一般的で単純なものです。キャラクターの外観を表すために、クワッドメッシュ（スプライト）にラップされた一連の [テクスチャ](https://docs.unity3d.com/Manual/Textures.html) アセットを使用します。テクスチャは、`.jpg`、`.png`、`.tiff`、`.psd`、または [Unityでサポートされている](https://docs.unity3d.com/Manual/ImportingTextures) その他の画像ファイル形式に基づくことができます。

::: tip
開発ワークフローに最も適したファイル形式を選択してください。プロジェクトをビルドすると、Unityはすべてのソースリソース（テクスチャ、オーディオ、ビデオなど）をターゲットプラットフォームに最適な形式に自動的に変換するため、プロジェクトにリソースを保存する際の形式は重要ではありません。Unityがプロジェクトアセットを管理する方法の詳細については、[公式ドキュメント](https://docs.unity3d.com/Manual/AssetWorkflow) を参照してください。
:::

シーン上のスプライトキャラクターメッシュの初期（スケーリングされていない）サイズは、参照解像度（カメラ設定）、キャラクターの `Pixel Per Unit` プロパティ（設定メニューで各キャラクターアクターに設定）、およびソーステクスチャの解像度によって異なります。

最高のレンダリング品質と最適なパフォーマンスを実現するには、通常、すべてのキャラクターに対してデフォルトの `Pixel Per Unit` 値（100）を維持し、テクスチャ解像度を介して目的の初期キャラクターサイズを制御することをお勧めします。たとえば、ゲームの参照解像度がデフォルトの `1920x1080` ピクセルであるとします。キャラクターが画面の高さ全体を占めるようにするには、キャラクターのテクスチャの高さを（Photoshopや他の画像エディタでサイズ変更するなどして）`1080` ピクセルに設定します。別のキャラクターが画面の高さの2/3を占めるようにするには、高さを `1080 * 2/3` に設定します。

## ダイススプライトキャラクター

オープンソースの [SpriteDicing](https://github.com/elringus/sprite-dicing) パッケージで構築された `DicedSpriteCharacter` 実装により、キャラクタースプライトのテクスチャ領域を再利用することで、ビルドサイズとテクスチャメモリを大幅に削減できます。

![Sprite Dicing](https://i.gyazo.com/af08d141e7a08b6a8e2ef60c07332bbf.png)

[Unity Package Manager](https://docs.unity3d.com/Manual/upm-ui.html) 経由でパッケージをインストールします。Package Managerウィンドウを開き（Window -> Package Manager）、「+」ボタンをクリックして、「Add package from git URL」を選択し、次のURLを入力します。

```
https://github.com/elringus/sprite-dicing.git?path=/plugins/unity/Assets/SpriteDicing
```

— 入力フィールドに入力して「Add」をクリックします。

::: info NOTE
Gitリポジトリからパッケージをインストールする前に、[Gitクライアント](https://git-scm.com/downloads) がマシンにインストールされており、Git実行可能パスが [PATHシステム環境変数](https://en.wikipedia.org/wiki/PATH_(variable)) に設定されていることを確認してください（通常はインストール中に自動的に実行されます）。
:::

「SpriteDicing」拡張機能がUPM経由でインストールされると、キャラクター実装リストに `Naninovel.DicedSpriteCharacter` オプションが表示されます。

![](https://i.gyazo.com/25360c9287a7b5a6a7feaba987a2bbb4.png)

キャラクターの外観を含む `DicedSpriteAtlas` アセットは、ダイススプライトキャラクターのリソースとして使用されます。各外観は、アトラスに含まれるダイススプライトに名前でマップされます。

::: tip
キャラクターメタデータプロパティ（ピクセルパーユニット、ピボットなど）はシーン上でキャラクターを表すために使用されるレンダーテクスチャに適用されますが、同様のダイスアトラスプロパティは生成されたダイススプライトに適用されます。アトラスプロパティを変更する場合は、変更を有効にするために再構築することを忘れないでください。
:::

次のビデオガイドでは、ダイススプライトアトラスの作成と構成、作成されたアトラスに基づく新しいダイスキャラクターの追加、シナリオスクリプトからのキャラクターの制御について説明しています。

![](https://www.youtube.com/watch?v=6PdOAOsnhio)

利用可能なダイスオプションと使用例の詳細については、拡張機能のドキュメントを参照してください: https://dicing.elringus.com/guide/unity。

::: tip EXAMPLE
[ダイスアクターサンプル](/ja/guide/samples#ダイスアクター) でダイスアクターの設定例を見つけてください。
:::

## レイヤーキャラクター

レイヤー実装により、複数のレイヤーからキャラクターを作成し、実行時にシナリオスクリプトを介して個別またはグループで切り替えることができます。

::: tip
レイヤーアクターの実装は進化しており、現在は（汎用とは対照的に）すべてのレンダリング機能をサポートする最も柔軟なものです。レイヤー式を使用したくない場合でも、代わりにUnityのAnimatorやその他のカスタムシステムで外観を制御する場合、またはパーティクルシステムなどの自明でないオブジェクトをレンダリングしたり、サードパーティのレンダラーを利用したりする必要がある場合は、汎用またはカスタム実装に頼る前に、レイヤーアクターで使用可能な [レンダリングのみ](/ja/guide/characters#外観管理のアウトソーシング) および [カメラレンダリング](/ja/guide/characters#カメラレンダリング) オプションを確認してください。
:::

レイヤーキャラクタープレハブを作成するには、`Create -> Naninovel -> Character -> Layered` アセットコンテキストメニューを使用します。[プレハブ編集モード](https://docs.unity3d.com/Manual/EditingInPrefabMode.html) に入ってレイヤーを作成します。いくつかのレイヤーとグループがデフォルトで作成されます。それらを使用することも、削除して独自のものに追加することもできます。

[Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) 派生コンポーネント（`SpriteRenderer`、`MeshRenderer` など）を持つルートプレハブオブジェクトの各子ゲームオブジェクトは *レイヤー* と見なされます。その他のオブジェクトは *グループ* と見なされます。整理と変換の目的以外に、レイヤーをグループ内に配置すると、シナリオスクリプト内の単一の式で単一のレイヤーを選択したり、グループ内のすべてのレイヤーを無効/有効にしたりできます（これについては後で詳しく説明します）。

::: info NOTE
デフォルト（非カメラ）レンダリングモードでは、`Sprite Renderer` の「simple」描画モードのみがサポートされています。他のモードを選択すると、simpleに設定されているかのようにレンダリングされます。
:::

特定のレイヤーをデフォルトで非表示にするには、レンダラーコンポーネントを無効にします（ゲームオブジェクトではありません）。

プレハブ上に描画された白いフレームは、実行時にレンダーテクスチャにレンダリングされるアクターキャンバスを記述するために使用されます。テクスチャメモリの浪費を防ぎ、アンカーが正しく機能するように、レイヤーとグループを移動してフレーム内の空の領域を最小限に抑えてください。カスタムキャンバスサイズを設定するには（たとえば、一部のレイヤーがアニメーション化されていてデフォルトのキャンバスの外に伸びる可能性がある場合）、ルートオブジェクトに `Render Canvas` コンポーネントを追加し、`Size` プロパティを設定します。

![](https://i.gyazo.com/4ff103c27858ac9671ba3b94ab1ade20.png)

ルートゲームオブジェクトをスケーリングして、アクターのデフォルトサイズを微調整できます。

Photoshopでレイヤーキャラクターアートを作成する場合は、Unityの [PSD Importerパッケージ](https://docs.unity3d.com/Packages/com.unity.2d.psdimporter@3.0/manual/index.html) を使用して、すべてのレイヤーとその位置を保持したままキャラクタープレハブを自動的に生成することを検討してください。レイヤー階層を保持するには、インポート設定で `Use Layer Grouping` オプションを有効にしてください。

::: tip
スプライトを使用する場合は、レンダリングの問題を防ぐために、テクスチャインポート設定で `Mesh Type` を `Full Rect` に設定してください。

![](https://i.gyazo.com/16ebf843081c826e0add1a6304c2608f.png)
:::

作成したレイヤープレハブをキャラクターリソースに追加することを忘れないでください（`Naninovel -> Resources -> Characters`）。リソースレコードを構成するときに、`Naninovel.LayeredCharacter` 実装を選択し、プレハブを `Resource` フィールドにドロップします。

シナリオスクリプトでレイヤーキャラクターを制御するには、他のキャラクター実装と同じ方法で [@char] コマンドを使用します。唯一の違いは外観の設定方法です。単一のIDの代わりに、*レイヤー合成式* を使用します。3つの式のタイプがあります。

- グループ内の単一のレイヤーを有効にする: `group>layer`
- レイヤーを有効にする: `group+layer`
- レイヤーを無効にする: `group-layer`

たとえば、"Uniform"、"SportSuit"、"Pajama" の3つのレイヤーを持つ "Body" グループを持つ "Miho" キャラクターを考えてみましょう。"Uniform" レイヤーを有効にし、他のすべてを無効にするには、次のコマンドを使用します。

```nani
@char Miho.Body>Uniform
```

グループ内の他のレイヤーに影響を与えずにレイヤーを有効または無効にするには、">" の代わりにそれぞれ "+" と "-" を使用します。コンマで区切って複数の合成式を指定することもできます。

```nani
; メガネを有効にし、帽子を無効にし、"Cool" 感情を選択します。
@char CharId.Head/Accessories+BlackGlasses,Head-Hat,Head/Emotions>Cool
```

グループ外のレイヤー（ルートプレハブオブジェクトの子）を選択するには、グループ部分をスキップします。例：

```nani
; "Halo" レイヤーオブジェクトがプレハブルートの下に配置されている場合、それを無効にします。
@char CharId.-Halo
```

合成式でレイヤー名を省略することで、グループ内のすべてのレイヤー（および選択式を使用している場合はさらにその隣接レイヤー）に影響を与えることも可能です。

```nani
; "Body/Decoration" グループ内のすべてのレイヤーを無効にします。
@char CharId.Body/Decoration-

; 既存のすべてのレイヤーを有効にします。
@char CharId.+

; "Poses/Light" と "Poses/Dark" グループがある場合、"Light" グループ内の
; すべてのレイヤーを有効にし、"Dark" グループ内のレイヤーを無効にします。
@char CharId.Poses/Light>
```

上記の式は、ターゲットグループの直接の子孫だけでなく、基礎となるグループに含まれるすべてのレイヤーに再帰的に影響します。

外観が指定されていない場合（たとえば、以前に外観を設定せずに `@char CharId`）、デフォルトの外観が使用されます。レイヤーキャラクターのデフォルトの外観は、エディタでのレイヤープレハブの見た目と同じです。

以下のビデオは、レイヤーキャラクターを設定し、Naninovelコマンドを介して制御する方法を示しています。

![](https://www.youtube.com/watch?v=Bl3kXrg8tiI)

::: info NOTE
ビデオに表示されている `@char Miho.Shoes>` コマンドは、実際には "Shoes" グループを選択し（すべての隣接グループを無効にし）、隠すわけではありません。グループを隠すための正しいコマンドは `@char Miho.Shoes-` です。
:::

`Layered Character Behaviour` コンポーネントの `Composition Map` プロパティを介して、合成式をキーにマップすることが可能です。

![](https://i.gyazo.com/ede5cde3548a3187aa714d3e140750ba.png)

— その後、キーを使用してレイヤーアクターの外観を指定できます。

```nani
; "Body>Uniform,Hair/Back>Straight,Hair/Front>Straight,Shoes>Grey" と同等です。
@char Miho.Uniform
; "Hair/Back>Straight,Hair/Front>Straight" と同等です。
@char Miho.StraightHair
; キーと式を組み合わせることも可能です。
@char Miho.Uniform,Hair/Front>Short
```

レイヤーキャラクタープレハブを編集しているときに、マップレコードを右クリックして「Preview Composition」を選択することで、マップされた合成式をプレビューできます。別のメニュー項目 — 「Paste Current Composition」 — は、キャラクターの現在の合成式文字列（階層内の有効/無効なスプライトレンダラーに基づく）を生成し、検査されたレコードに貼り付けます。これを使用して、現在のプレハブ状態を合成項目にすばやくマップします。

![](https://i.gyazo.com/84a2f8e51997cdccbfb8321d58586d2a.mp4)

レイヤーオブジェクトは、実行時にUnityカメラによって直接レンダリングされないことに注意してください。代わりに、合成（外観）が変更されるたびに一度、一時的なレンダーテクスチャにレンダリングされ、Naninovelカメラに表示されるカスタムメッシュに供給されます。この設定は、半透明のオーバードローの問題を防ぎ、トランジションアニメーション効果をサポートするために必要です。

レイヤーキャラクターにアニメーションやその他の動的な動作を適用したい場合は、`Layered Character Behaviour` コンポーネントにある `Animated` プロパティを有効にしてください。プロパティが有効になっている場合、レイヤーはフレームごとに（外観の変更ごとに一度ではなく）レンダリングされます。

### 外観管理のアウトソーシング

さまざまな組み込みレンダリング機能（半透明のオーバードロー処理、トランジションエフェクト、ブラー、被写界深度のサポートなど）をサポートするためにレイヤー実装が役立つ場合がありますが、Unityの [Animator](https://docs.unity3d.com/Manual/class-Animator.html) などの外部ツールを使用してアクターの外観を管理したい場合があります。デフォルトでは、レイヤー動作は `On Appearance Changed` イベントを介して外観の変更について通知するときにレイヤー式を使用しますが、そのような場合には望ましくない場合があります。

`Render Only` オプションを有効にすると、レイヤー関連の動作が無効になり、スクリプトコマンドで指定されたとおりに外観をイベントで報告するようになります。また、初期プレハブレイヤー構成に基づいてデフォルトの外観を評価しないようにするために、動作コンポーネントで `Default Appearance` を指定する必要があります。

### カメラレンダリング

キャラクタープレハブにパーティクルシステム、トレイル、スプライトマスク、カスタム/サードパーティレンダラーなどの自明でないレンダラーが含まれている場合でも、`Layered Behaviour` コンポーネントの `Render Camera` フィールドにカメラを割り当てることで、レイヤー実装で使用できます（カメラはキャラクターのプレハブ内にある必要があります）。

割り当てられると、カスタムレンダリング手順の代わりに、アクターはカメラを使用してコンテンツをレンダリングします。これにより、ステンシルサポートの欠如など、固有の制限がすべて解除されます。欠点は、コンテンツがアクターテクスチャにのみレンダリングされ（メインカメラに「リーク」しない）ようにするために、この種のアクターをレンダリングするためだけにカメラ [レイヤー](https://docs.unity3d.com/Manual/Layers.html) を予約する必要があることです。

Unityには合計32のレイヤーがあり、そのうち8つはエンジン内部用に予約されています。残りのレイヤーは自由に使用できます（デフォルトでは使用されていません）。Naninovelがカメラモードでレイヤーアクターをレンダリングするためにレイヤーを使用できるようにするには、`Naninovel` で始まるレイヤー名を付けます。例：`Naninovel 1`、`Naninovel 2` など。

![](https://i.gyazo.com/dfbb4306553c85a4683fffb0fef03de3.png)

追加するレイヤーの総数は、表示されているかどうかに関係なく、任意の時点でスポーンされる一意のカメラレンダリングレイヤーアクターの最大数によって異なります。レイヤーアクターがレンダリングされると、プールからレイヤーを保持します。アクターが非表示になると、レイヤーを解放し、他のアクターが再利用できるようにします。ただし、アクターは外観の変更時にもレンダリングされます。これは、シーンに最初に追加されたとき（非表示であっても）、またはゲームがロードまたはロールバックされたときに発生するため、**レイイヤープールサイズは、一度に表示されるアクターの数だけでなく、一度にスポーンされるカメラレンダリングアクターの総数に対応する必要があります**。アクターを非表示にした後に破棄（デスポーン）するには、[@remove] コマンドを使用します。

レイヤーを追加した後、Naninovelのカメラ構成の `Custom Camera Prefab` に、`Naninovel ...` レイヤーが無効になっているカリングマスクを持つカメラプレハブを割り当てます。これは、「生の」レイヤーアクターがメインのNaninovelカメラにリークするのを防ぐために必要です。割り当てられたカメラは、レイヤーアクタープレハブ内で使用したカメラではなく、専用のカメラプレハブである必要があることに注意してください。

![](https://i.gyazo.com/e2f713e4e212718f50e028cdf546aaba.png)

カメラレンダリングモードでは、`Layered Actor Layer` コンポーネントがアタッチされている場合、レイヤーアクタープレハブのゲームオブジェクトはレイヤーと見なされ、その他のオブジェクトはグループと見なされます。コンポーネントをアタッチした後、`On Layer Held` および `On Layer Released` Unityイベントを使用して、カメラレイヤーが保持および解放されたときに何が起こるかを構成します。通常、保持されたレイヤーをホストゲームオブジェクトに割り当てて関連するレンダラーを有効にし、解放されたときにレンダラーを無効にします（オブジェクトが他のカメラによって選択されないようにするため）。

![](https://i.gyazo.com/4dbfe57dbf6b7365e1e7db78f707f412.png)

レイヤーのアクティブ状態もカメラモードでは異なって反映されます。レンダラーコンポーネントの有効状態の代わりに、ゲームオブジェクトのアクティブ状態が使用されます。アクターのデフォルトの外観を設定するには、ゲームオブジェクトを有効/無効にします。

::: tip
レイヤーに多くの子が含まれている場合、それら個別にレイヤー保持/解放イベントを設定するのは面倒です。この場合、カスタムイベントハンドラーを使用して変更を一括適用します。レイヤーのすべての子レンダラーに変更を適用する [例](https://discord.com/channels/545676116871086080/1369982706393284700) を確認してください。
:::

カメラモードには `Render Canvas` コンポーネントが必要なので、レイヤーアクタープレハブのルートにアタッチされていることを確認してください。これは通常のレンダリングモードと同様に機能し、レンダーテクスチャサイズを制限するため、コンパクトに保ってください。

アクターのレンダリングに追加のレイヤーが必要な場合（たとえば、UnityのLights 2D専用のレイヤーなど）、レイヤー動作コンポーネントにある `Camera Mask` プロパティを介して追加します。Naninovelは、アクターをレンダリングするときに、カメラのカリングマスクで指定されたレイヤーを保持します。

::: tip EXAMPLE
[レイヤーアクターサンプル](/ja/guide/samples#レイヤーアクター) でレイヤーアクターの設定例を見つけてください。
:::

## 汎用キャラクター

汎用キャラクターは、最も柔軟なキャラクターアクター実装です。これは、ルートオブジェクトに `Generic Character Behaviour` コンポーネントがアタッチされたプレハブに基づいています。外観の変更およびその他すべてのキャラクターパラメータは [Unityイベント](https://docs.unity3d.com/Manual/UnityEvents.html) としてルーティングされ、基になるオブジェクトの動作を好きなように実装できます。

![](https://i.gyazo.com/d0ea1bf7a5ed3b4bb7eb70c4ddbfeba2.png)

::: info NOTE
汎用アクター実装は、シナリオスクリプトからのイベントをルーティングするだけであり、外観や可視性の変更コマンドにアクターがどのように反応するか、話者ハイライト機能をサポートするかどうか、どのようにサポートするかなど、基になる動作を実装するのはユーザー次第です。アクター関連の機能のほとんどが、汎用実装で自動的に機能することを期待しないでください。
:::

テンプレートから汎用キャラクタープレハブを作成するには、`Create -> Naninovel -> Character -> Generic` コンテキストアセットメニューを使用します。

3Dリグモデルを汎用キャラクターとして設定し、[Animator](https://docs.unity3d.com/Manual/class-AnimatorController.html) コンポーネントを介して外観の変更をリグアニメーションにルーティングする例については、次のビデオチュートリアルを確認してください。ビデオは古いNaninovelバージョンでキャプチャされており、一部のプロパティとコンポーネント名が現在とは異なっていることに注意してください。最新情報については、上記のドキュメントを参照してください。

![](https://www.youtube.com/watch?v=HPxhR0I1u2Q)

::: tip
Unityの `Animator` コンポーネントは、ゲームオブジェクトが同じフレームで有効化/無効化されたときに `SetTrigger` の登録に失敗する可能性があります。可視性の変更を処理するために `GameObject.SetActive` を使用する場合（上記のチュートリアルで示されているように）、代わりにレンダラーを持つ子オブジェクトを有効化/無効化することを検討してください。
:::

::: tip EXAMPLE
3Dアニメーションモデルをホストするために汎用キャラクター実装が使用されている [汎用アクターサンプル](/ja/guide/samples#ジェネリックアクター) を確認してください。
:::

## ビデオキャラクター

ビデオキャラクターは、外観を表すためにループされた [ビデオクリップ](https://docs.unity3d.com/Manual/class-VideoClip) アセットを使用します。

各プラットフォームでサポートされているビデオ形式については、[ビデオソースに関するUnityドキュメント](https://docs.unity3d.com/Manual/VideoSources-FileCompatibility.html) を参照してください。

アルファチャンネル（透明度）付きのビデオを使用する場合は、[サポートされている形式に関するガイド](https://docs.unity3d.com/Manual/VideoTransparency.html) を参照してください。

特定の外観がループしないようにするには、外観名に `NoLoop`（大文字と小文字を区別しない）を追加します。

## Live2Dキャラクター

Live2Dキャラクター実装は、[Live2D Cubism](https://www.live2d.com) 2Dモデリングおよびアニメーションソフトウェアで作成されたアセットを使用します。

![](https://i.gyazo.com/b81df72fc7afaed569520496cbee09f0.mp4)

この実装を使用するには、まず [Live2D Cubism SDK for Unity](https://live2d.github.io/#unity) をインストールする必要があります。インストールと使用方法については、公式Live2Dドキュメントを参照してください。

Live2D SDK for Unityをインストールした後、`Naninovel/Extensions/Enable Live2D` エディタメニュー項目をクリックして、Live2Dとエンジンの統合を提供するNaninovelモジュールをアクティブにします。

![](https://i.gyazo.com/e27ee50e8107147e20503a955ddcc548.png)

::: info NOTE
このサードパーティの商用製品との統合は、主にNaninovelを別のツールと連携させる方法の例として機能します。サンプル統合をLive2Dの更新や変更と互換性のある状態に保つことに尽力していますが、機能は最小限にとどまり、サンプルの範囲を超えてNaninovelで別の製品を使用することに関するサポートや支援を提供することはできないことに注意してください。
:::

実装のリソースとして使用されるLive2Dモデルプレハブには、ルートオブジェクトに `Live2DController` コンポーネントがアタッチされている必要があります。外観の変更は、[SetTrigger](https://docs.unity3d.com/ScriptReference/Animator.SetTrigger.html) コマンドとしてアニメーターコンポーネントにルーティングされ、外観がトリガー名になります。たとえば、「Kaori」Live2Dキャラクタープレハブがあり、「Surprise」という名前のトリガーを呼び出したい場合は、次のコマンドを使用します。

```nani
@char Kaori.Surprise
```

上記のコマンドは、プレハブにアタッチされたアニメーターコントローラーで「Surprise」引数を使用して [SetTrigger](https://docs.unity3d.com/ScriptReference/Animator.SetTrigger.html) を呼び出そうとするだけであることに注意してください。基になる [animator](https://docs.unity3d.com/Manual/Animator) ステートマシンを自分で構成する必要があります。

::: info NOTE
Cubism SDK for Unityの現在の実際のバージョンは、`Animator` コンポーネントと直接連携しています。Cubism 2.xで以前使用されていた式とポーズ（expression.jsonおよびpose.jsonとしてエクスポート）は現在 [非推奨](https://docs.live2d.com/cubism-sdk-tutorials/blendexpression) であり、NaninovelのLive2D拡張機能ではサポートされていません。
:::

Live2Dの `CubismLookController` および `CubismMouthController` コンポーネントが存在し、Live2Dモデルプレハブに設定されている場合、`Live2DController` はオプションでそれらを使用して、キャラクターの視線方向と口のアニメーション（リップシンク機能）を制御できます。

![](https://i.gyazo.com/498fe948bc5cbdb4dfc5ebc5437ae6b4.png)

設定の詳細については、[視線追跡](https://docs.live2d.com/cubism-sdk-tutorials/lookat) および [リップシンク](https://docs.live2d.com/cubism-sdk-tutorials/lipsync) に関するLive2Dドキュメントを参照してください。

モデルが小さすぎたり大きすぎたりする場合は、[ビデオガイドに示されているように](https://youtu.be/rw_Z69z0pAg?t=353) ルートLive2Dプレハブゲームオブジェクトの初期スケールを設定します。

内部的に、Live2Dモデルはテクスチャにレンダリングされ、その後画面に投影されます。これは、キャラクターをフェードするときの半透明のオーバードローアーティファクトを防ぐために必要です。Naninovelはレンダーキャンバスのサイズを自動的に評価しようとしますが、モデルに初期境界の外に移動するアニメーションパーツが含まれている場合、パーツはクリップされます。これを防ぐには、Live2Dプレハブのルートゲームオブジェクトに `Render Canvas` コンポーネントを追加し、キャンバスの希望するサイズを手動で設定します。[ギズモ](https://docs.unity3d.com/Manual/GizmosMenu.html) を有効にして、プレハブモードで現在のレンダーキャンバスサイズをプレビューします。

![](https://i.gyazo.com/23f916ae104f57828914221333e42dbf.mp4)

サイズが大きいほどテクスチャが消費するメモリが多くなるため、できるだけ小さく保つことに注意してください。

次のビデオガイドでは、Cubism EditorからのLive2Dキャラクターのエクスポート、プレハブの構成、単純なアニメーターステートマシンの作成、およびシナリオスクリプトからのキャラクターの制御について説明しています。

![](https://www.youtube.com/watch?v=rw_Z69z0pAg)

::: tip EXAMPLE
Live2DキャラクターがNaninovelで使用されている [Live2Dサンプル](/ja/guide/samples#live2d) を確認してください。
:::

## Spineキャラクター

Spineキャラクター実装は、[Spine](http://esotericsoftware.com) 2Dモデリングおよびアニメーションソフトウェアで作成されたアセットを使用します。

![](https://i.gyazo.com/08b04de115d97427d152cb5f37065d2d.mp4)

この実装を使用するには、まず [Spine runtime for Unity](http://esotericsoftware.com/spine-unity-download) をインストールする必要があります。インストールと使用方法については、[公式ドキュメント](http://esotericsoftware.com/spine-unity) を参照してください。

Spine runtime for Unityをインストールした後、`Naninovel/Extensions/Enable Spine` エディタメニュー項目をクリックして、Spineとエンジンの統合を提供するNaninovelモジュールをアクティブにします。

![](https://i.gyazo.com/2fb6c27f6e2149b501c0025dd6bd67f0.png)

::: info NOTE
このサードパーティの商用製品との統合は、主にNaninovelを別のツールと連携させる方法の例として機能します。サンプル統合をSpineの更新や変更と互換性のある状態に保つことに尽力していますが、機能は最小限にとどまり、サンプルの範囲を超えてNaninovelで別の製品を使用することに関するサポートや支援を提供することはできないことに注意してください。
:::

実装のリソースとして使用されるSpineキャラクタープレハブには、ルートオブジェクトに `Spine Controller` コンポーネントがアタッチされている必要があります。シナリオスクリプトコマンド（`@char` など）からの外観の変更は、[汎用実装](/ja/guide/characters#汎用キャラクター) と同様に、コントローラーの `On Appearance Changed` イベントにルーティングされます。イベントは好きなように処理できます。たとえば、Spineの `SetAnimation` メソッドを使用したり、Unityのアニメーターコントローラーでトリガーを呼び出したりします。

![](https://i.gyazo.com/6a2772a3e4137413a7c1587788c54c41.png)

::: tip
`Spine Controller` から継承されたカスタムコンポーネントを使用することが可能です。これにより、仮想メソッドと関連する動作をオーバーライドできます（たとえば、特定の期間またはトランジションパラメータで外観の変更を処理する）。
:::

内部的に、Spineモデルはテクスチャにレンダリングされ、その後画面に投影されます。これは、キャラクターをフェードするときの半透明のオーバードローアーティファクトを防ぐために必要です。テクスチャサイズを指定するには、`Render Canvas` コンポーネント（`Spine Controller` を追加すると自動的にアタッチされます）を使用します。[ギズモ](https://docs.unity3d.com/Manual/GizmosMenu.html) を有効にして、プレハブモードで現在のサイズをプレビューします。サイズが大きいほどテクスチャが消費するメモリが多くなるため、できるだけ小さく保つことに注意してください。

::: info NOTE
Spineの [Skeleton Render Separator](https://github.com/pharan/spine-unity-docs/blob/master/spine-unity-skeletonrenderseparator)（マルチレンダー）ワークフローはサポートされていません。そのワークフローをNaninovelと統合するには、カスタムキャラクター実装を作成してください。
:::

::: tip EXAMPLE
SpineキャラクターがNaninovelで使用されている [spineサンプル](/ja/guide/samples#spine) を確認してください。
:::

## ナレーターキャラクター

ナレーターキャラクターはシーン上での存在感（外観、位置、視線方向、色合いなど）を持ちませんが、表示されるメッセージを作成することができ、関連する構成オプション（表示名、メッセージの色、リンクされたプリンターなど）を持っています。

![](https://i.gyazo.com/f1ee43da312b29f3236cf772d9ea9fa7.png)

## テクスチャへのレンダリング

すべての実装（汎用を除く）のキャラクターおよび背景アクターをテクスチャアセットにレンダリングすることが可能です。これは、カスタムUI、プリンター、マテリアル、またはその他の互換性のあるソースに割り当てることができます。

アクター構成の `Render Texture` プロパティを使用してレンダーテクスチャアセットを割り当てます。テクスチャが割り当てられると、アクターはシーン上のゲームオブジェクトとして表示されず、テクスチャにレンダリングされます。`Render Rectangle` プロパティを使用すると、テクスチャにレンダリングするアクターの領域を指定できます。

![](https://i.gyazo.com/7224fa44695507b0ce0274940d630299.png)

::: info NOTE
[Addressablesパッケージ](https://docs.unity3d.com/Manual/com.unity.addressables.html) を使用する場合、Unityは [アセット参照を適切に追跡できません](https://issuetracker.unity3d.com/product/unity/issues/guid/1277169)。これにより、ビルドでレンダーテクスチャが重複し、機能が正しく動作しなくなる可能性があります。（`AssetReference` APIを介して）参照を手動で処理するか、以下に示すように `Get Actor Render Texture` コンポーネントを使用してください。

![](https://i.gyazo.com/92772b1fa51e6042efcd3de67d05fd79.png)
:::

アクターがテクスチャにレンダリングされると、変換（位置、回転、スケール）およびその他のいくつかの変更は効果がありません。代わりに、レンダーテクスチャのホストオブジェクト（テクスチャがUI生画像コンポーネントに割り当てられている場合は画像など）を変換します。

以下のビデオは、Live2Dキャラクターをテクスチャにレンダリングし、それをカスタムテキストプリンターに割り当てる方法を示しています。プリンターはキャラクターにリンクされているため、関連するテキストメッセージが処理されると、キャラクターはプリンターとともに自動的に表示および非表示になります。

![](https://www.youtube.com/watch?v=81OTbSAnWbw)

他のすべてのキャラクターおよび背景実装タイプ（汎用を除く）は、Live2Dの例と同様にテクスチャにレンダリングするように設定できます。

## 複数の外観

汎用、Live2D、Spineアクターは、一度に適用される複数の外観をサポートしています。例：

```nani
@char Kohaku.Body/Pose1,Face/Smile
```

— は `Body/Pose1` および `Face/Smile` 外観変更イベントを呼び出します。これを使用して、複数のアニメータートリガーを同時にトリガーし、複雑なアニメーション状態を設定します。すべての外観は、アクターの状態とともにシリアル化され、ゲームのロードまたはロールバック時に復元されます。

![](https://i.gyazo.com/f438703100ca8c695de814fe08ff2427.mp4)
